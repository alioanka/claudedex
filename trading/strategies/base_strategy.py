"""
Base Strategy - Foundation class for all trading strategies in ClaudeDex Trading Bot

This module provides the abstract base class that all trading strategies must inherit from.
"""

from abc import ABC, abstractmethod
import asyncio
from typing import Dict, List, Optional, Tuple, Any, Union
from decimal import Decimal
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import uuid

from loguru import logger
import numpy as np

from ...utils.helpers import calculate_percentage_change, calculate_slippage
from ...utils.constants import (
    MAX_POSITION_SIZE_PERCENT, 
    DEFAULT_STOP_LOSS,
    RISK_PARAMETERS
)


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class SignalStrength(Enum):
    """Signal strength levels"""
    VERY_STRONG = "very_strong"
    STRONG = "strong"
    MODERATE = "moderate"
    WEAK = "weak"
    VERY_WEAK = "very_weak"


class StrategyState(Enum):
    """Strategy execution states"""
    IDLE = "idle"
    ANALYZING = "analyzing"
    ENTERING = "entering"
    IN_POSITION = "in_position"
    EXITING = "exiting"
    STOPPED = "stopped"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_name: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    signal_type: SignalType = SignalType.HOLD
    strength: SignalStrength = SignalStrength.WEAK
    token_address: str = ""
    chain: str = ""
    entry_price: Optional[Decimal] = None
    target_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    position_size: Optional[Decimal] = None
    confidence: float = 0.0
    timeframe: str = "5m"
    indicators: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    expires_at: Optional[datetime] = None


@dataclass
class StrategyPerformance:
    """Strategy performance metrics"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_profit: Decimal = Decimal("0")
    total_loss: Decimal = Decimal("0")
    win_rate: float = 0.0
    average_win: Decimal = Decimal("0")
    average_loss: Decimal = Decimal("0")
    profit_factor: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    recovery_factor: float = 0.0
    average_trade_duration: timedelta = timedelta()
    best_trade: Optional[Dict[str, Any]] = None
    worst_trade: Optional[Dict[str, Any]] = None
    current_streak: int = 0
    max_win_streak: int = 0
    max_loss_streak: int = 0


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize base strategy
        
        Args:
            config: Strategy configuration
        """
        self.config = config
        self.name = config.get("name", self.__class__.__name__)
        self.enabled = config.get("enabled", True)
        self.state = StrategyState.IDLE
        
        # Risk management parameters
        self.max_position_size = Decimal(str(config.get(
            "max_position_size", 
            MAX_POSITION_SIZE_PERCENT
        )))
        self.default_stop_loss = Decimal(str(config.get(
            "default_stop_loss",
            DEFAULT_STOP_LOSS
        )))
        self.max_concurrent_positions = config.get("max_concurrent_positions", 3)
        self.risk_per_trade = Decimal(str(config.get("risk_per_trade", 0.02)))
        
        # Strategy-specific parameters
        self.timeframe = config.get("timeframe", "5m")
        self.lookback_period = config.get("lookback_period", 100)
        self.min_confidence = config.get("min_confidence", 0.6)
        self.min_volume = config.get("min_volume", 10000)
        self.min_liquidity = config.get("min_liquidity", 50000)
        
        # Performance tracking
        self.performance = StrategyPerformance()
        self.active_positions: Dict[str, TradingSignal] = {}
        self.signal_history: List[TradingSignal] = []
        self.trade_history: List[Dict[str, Any]] = []
        
        # Internal state
        self._last_analysis_time: Dict[str, datetime] = {}
        self._analysis_cooldown = timedelta(seconds=config.get("analysis_cooldown", 60))
        self._position_entry_times: Dict[str, datetime] = {}
        
        logger.info(f"Initialized strategy: {self.name}")
    
    @abstractmethod
    async def analyze(
        self,
        market_data: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Analyze market data and generate trading signal
        
        Args:
            market_data: Current market data including price, volume, indicators
            
        Returns:
            Trading signal if conditions are met, None otherwise
        """
        pass
    
    @abstractmethod
    async def calculate_indicators(
        self,
        price_data: List[float],
        volume_data: List[float]
    ) -> Dict[str, Any]:
        """
        Calculate strategy-specific technical indicators
        
        Args:
            price_data: Historical price data
            volume_data: Historical volume data
            
        Returns:
            Dictionary of calculated indicators
        """
        pass
    
    @abstractmethod
    def validate_signal(
        self,
        signal: TradingSignal,
        market_data: Dict[str, Any]
    ) -> bool:
        """
        Validate trading signal before execution
        
        Args:
            signal: Trading signal to validate
            market_data: Current market data
            
        Returns:
            True if signal is valid, False otherwise
        """
        pass
    
    async def execute(
        self,
        signal: TradingSignal,
        order_manager: Any
    ) -> Dict[str, Any]:
        """
        Execute trading signal
        
        Args:
            signal: Trading signal to execute
            order_manager: Order management system
            
        Returns:
            Execution result
        """
        try:
            # Check if strategy is enabled
            if not self.enabled:
                logger.warning(f"Strategy {self.name} is disabled")
                return {"status": "skipped", "reason": "strategy_disabled"}
            
            # Check state
            if self.state == StrategyState.STOPPED:
                logger.warning(f"Strategy {self.name} is stopped")
                return {"status": "skipped", "reason": "strategy_stopped"}
            
            # Update state
            self.state = StrategyState.ENTERING
            
            # Log signal
            logger.info(
                f"Executing {signal.signal_type.value} signal for "
                f"{signal.token_address[:10]}... "
                f"[Confidence: {signal.confidence:.2f}]"
            )
            
            # Create order based on signal
            order = self._create_order_from_signal(signal)
            
            # Execute order
            result = await order_manager.execute_immediate(order)
            
            # Update tracking
            if result.get("status") == "success":
                await self._on_position_opened(signal, result)
            else:
                await self._on_position_failed(signal, result)
            
            # Update state
            self.state = StrategyState.IN_POSITION if result.get("status") == "success" else StrategyState.IDLE
            
            return result
            
        except Exception as e:
            logger.error(f"Strategy execution failed: {e}")
            self.state = StrategyState.IDLE
            return {"status": "error", "error": str(e)}
    
    async def check_exit_conditions(
        self,
        position: TradingSignal,
        market_data: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Check if position should be exited
        
        Args:
            position: Current position signal
            market_data: Current market data
            
        Returns:
            Exit signal if conditions are met
        """
        current_price = Decimal(str(market_data.get("price", 0)))
        
        if not current_price or not position.entry_price:
            return None
        
        # Check stop loss
        if position.stop_loss and current_price <= position.stop_loss:
            logger.warning(f"Stop loss triggered for {position.token_address[:10]}...")
            return self._create_exit_signal(position, "stop_loss", current_price)
        
        # Check take profit
        if position.target_price and current_price >= position.target_price:
            logger.info(f"Take profit triggered for {position.token_address[:10]}...")
            return self._create_exit_signal(position, "take_profit", current_price)
        
        # Check time-based exit
        if position.expires_at and datetime.now() >= position.expires_at:
            logger.info(f"Position expired for {position.token_address[:10]}...")
            return self._create_exit_signal(position, "expired", current_price)
        
        # Check strategy-specific exit conditions
        exit_signal = await self._check_custom_exit_conditions(position, market_data)
        
        return exit_signal
    
    async def _check_custom_exit_conditions(
        self,
        position: TradingSignal,
        market_data: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Check strategy-specific exit conditions (can be overridden)
        
        Args:
            position: Current position
            market_data: Current market data
            
        Returns:
            Exit signal if conditions are met
        """
        return None
    
    def calculate_position_size(
        self,
        signal: TradingSignal,
        account_balance: Decimal,
        current_price: Decimal
    ) -> Decimal:
        """
        Calculate position size based on risk management rules
        
        Args:
            signal: Trading signal
            account_balance: Current account balance
            current_price: Current token price
            
        Returns:
            Position size in base currency
        """
        # Kelly Criterion or fixed percentage
        if self.config.get("use_kelly_criterion", False):
            position_size = self._calculate_kelly_position(
                signal.confidence,
                account_balance
            )
        else:
            # Fixed percentage of account
            position_size = account_balance * self.risk_per_trade
        
        # Apply maximum position size limit
        max_position = account_balance * self.max_position_size
        position_size = min(position_size, max_position)
        
        # Adjust for signal strength
        strength_multiplier = self._get_strength_multiplier(signal.strength)
        position_size *= Decimal(str(strength_multiplier))
        
        # Ensure minimum position size
        min_position = self.config.get("min_position_size", 100)
        if position_size < min_position:
            return Decimal("0")
        
        return position_size
    
    def _calculate_kelly_position(
        self,
        confidence: float,
        account_balance: Decimal
    ) -> Decimal:
        """Calculate position size using Kelly Criterion"""
        # Kelly formula: f = (p * b - q) / b
        # where f = fraction to bet, p = probability of winning,
        # q = probability of losing, b = odds
        
        win_probability = confidence
        loss_probability = 1 - confidence
        
        # Estimate odds based on historical performance
        if self.performance.average_win > 0 and self.performance.average_loss > 0:
            odds = float(self.performance.average_win / self.performance.average_loss)
        else:
            odds = 2.0  # Default 2:1 risk/reward
        
        kelly_fraction = (win_probability * odds - loss_probability) / odds
        
        # Apply Kelly fraction with safety factor (usually 0.25)
        safety_factor = Decimal(str(self.config.get("kelly_safety_factor", 0.25)))
        position_size = account_balance * Decimal(str(max(0, kelly_fraction))) * safety_factor
        
        return position_size
    
    def _get_strength_multiplier(self, strength: SignalStrength) -> float:
        """Get position size multiplier based on signal strength"""
        multipliers = {
            SignalStrength.VERY_STRONG: 1.5,
            SignalStrength.STRONG: 1.2,
            SignalStrength.MODERATE: 1.0,
            SignalStrength.WEAK: 0.7,
            SignalStrength.VERY_WEAK: 0.5
        }
        return multipliers.get(strength, 1.0)
    
    def calculate_stop_loss(
        self,
        entry_price: Decimal,
        signal: TradingSignal
    ) -> Decimal:
        """
        Calculate stop loss price
        
        Args:
            entry_price: Entry price
            signal: Trading signal
            
        Returns:
            Stop loss price
        """
        # Use signal's stop loss if provided
        if signal.stop_loss:
            return signal.stop_loss
        
        # Calculate based on default percentage
        stop_loss_price = entry_price * (Decimal("1") - self.default_stop_loss)
        
        # Apply ATR-based stop if configured
        if self.config.get("use_atr_stop", False) and "atr" in signal.indicators:
            atr = Decimal(str(signal.indicators["atr"]))
            atr_multiplier = Decimal(str(self.config.get("atr_multiplier", 2.0)))
            stop_loss_price = entry_price - (atr * atr_multiplier)
        
        return stop_loss_price
    
    def calculate_take_profit(
        self,
        entry_price: Decimal,
        signal: TradingSignal
    ) -> Decimal:
        """
        Calculate take profit price
        
        Args:
            entry_price: Entry price
            signal: Trading signal
            
        Returns:
            Take profit price
        """
        # Use signal's target if provided
        if signal.target_price:
            return signal.target_price
        
        # Calculate based on risk/reward ratio
        risk_reward_ratio = Decimal(str(self.config.get("risk_reward_ratio", 2.0)))
        stop_loss = self.calculate_stop_loss(entry_price, signal)
        risk = entry_price - stop_loss
        
        take_profit_price = entry_price + (risk * risk_reward_ratio)
        
        return take_profit_price
    
    def _create_order_from_signal(self, signal: TradingSignal) -> Dict[str, Any]:
        """Create order from trading signal"""
        return {
            "signal_id": signal.id,
            "strategy": self.name,
            "token_address": signal.token_address,
            "chain": signal.chain,
            "side": signal.signal_type.value,
            "amount": signal.position_size,
            "price": signal.entry_price,
            "stop_loss": signal.stop_loss,
            "take_profit": signal.target_price,
            "time_in_force": "IOC",  # Immediate or cancel
            "metadata": signal.metadata
        }
    
    def _create_exit_signal(
        self,
        position: TradingSignal,
        reason: str,
        current_price: Decimal
    ) -> TradingSignal:
        """Create exit signal from position"""
        return TradingSignal(
            strategy_name=self.name,
            signal_type=SignalType.SELL,
            strength=SignalStrength.STRONG,
            token_address=position.token_address,
            chain=position.chain,
            entry_price=current_price,
            confidence=1.0,
            metadata={
                "exit_reason": reason,
                "original_position_id": position.id,
                "pnl": calculate_percentage_change(position.entry_price, current_price)
            }
        )
    
    async def _on_position_opened(
        self,
        signal: TradingSignal,
        result: Dict[str, Any]
    ) -> None:
        """Handle successful position opening"""
        # Add to active positions
        self.active_positions[signal.token_address] = signal
        
        # Record entry time
        self._position_entry_times[signal.token_address] = datetime.now()
        
        # Add to signal history
        self.signal_history.append(signal)
        
        # Log success
        logger.info(
            f"Position opened: {signal.token_address[:10]}... "
            f"Size: {signal.position_size} "
            f"Entry: {signal.entry_price}"
        )
    
    async def _on_position_failed(
        self,
        signal: TradingSignal,
        result: Dict[str, Any]
    ) -> None:
        """Handle failed position opening"""
        # Add to signal history with failed status
        signal.metadata["failed"] = True
        signal.metadata["failure_reason"] = result.get("error", "Unknown")
        self.signal_history.append(signal)
        
        # Log failure
        logger.error(
            f"Position failed: {signal.token_address[:10]}... "
            f"Reason: {result.get('error', 'Unknown')}"
        )
    
    async def _on_position_closed(
        self,
        position: TradingSignal,
        exit_price: Decimal,
        reason: str
    ) -> None:
        """Handle position closure"""
        # Remove from active positions
        if position.token_address in self.active_positions:
            del self.active_positions[position.token_address]
        
        # Calculate metrics
        entry_time = self._position_entry_times.get(position.token_address)
        if entry_time:
            duration = datetime.now() - entry_time
            del self._position_entry_times[position.token_address]
        else:
            duration = timedelta()
        
        # Calculate P&L
        pnl_percent = calculate_percentage_change(position.entry_price, exit_price)
        pnl_amount = position.position_size * pnl_percent / Decimal("100")
        
        # Update performance metrics
        self._update_performance(pnl_amount, pnl_percent, duration)
        
        # Add to trade history
        trade = {
            "signal_id": position.id,
            "token": position.token_address,
            "entry_price": position.entry_price,
            "exit_price": exit_price,
            "position_size": position.position_size,
            "pnl_amount": pnl_amount,
            "pnl_percent": pnl_percent,
            "duration": duration,
            "exit_reason": reason,
            "timestamp": datetime.now()
        }
        self.trade_history.append(trade)
        
        # Log closure
        logger.info(
            f"Position closed: {position.token_address[:10]}... "
            f"P&L: {pnl_percent:.2f}% ({pnl_amount:.2f}) "
            f"Reason: {reason}"
        )
    
    def _update_performance(
        self,
        pnl_amount: Decimal,
        pnl_percent: Decimal,
        duration: timedelta
    ) -> None:
        """Update strategy performance metrics"""
        self.performance.total_trades += 1
        
        if pnl_amount > 0:
            self.performance.winning_trades += 1
            self.performance.total_profit += pnl_amount
            self.performance.current_streak = max(0, self.performance.current_streak) + 1
            self.performance.max_win_streak = max(
                self.performance.max_win_streak,
                self.performance.current_streak
            )
        else:
            self.performance.losing_trades += 1
            self.performance.total_loss += abs(pnl_amount)
            self.performance.current_streak = min(0, self.performance.current_streak) - 1
            self.performance.max_loss_streak = max(
                self.performance.max_loss_streak,
                abs(self.performance.current_streak)
            )
        
        # Update averages
        if self.performance.winning_trades > 0:
            self.performance.average_win = (
                self.performance.total_profit / self.performance.winning_trades
            )
        
        if self.performance.losing_trades > 0:
            self.performance.average_loss = (
                self.performance.total_loss / self.performance.losing_trades
            )
        
        # Update win rate
        if self.performance.total_trades > 0:
            self.performance.win_rate = (
                self.performance.winning_trades / self.performance.total_trades
            )
        
        # Update profit factor
        if self.performance.total_loss > 0:
            self.performance.profit_factor = float(
                self.performance.total_profit / self.performance.total_loss
            )
        
        # Update average trade duration
        total_duration = sum(
            (t["duration"] for t in self.trade_history),
            timedelta()
        )
        if self.performance.total_trades > 0:
            self.performance.average_trade_duration = (
                total_duration / self.performance.total_trades
            )
    
    def should_analyze(
        self,
        token_address: str,
        market_data: Dict[str, Any]
    ) -> bool:
        """
        Check if analysis should be performed
        
        Args:
            token_address: Token to analyze
            market_data: Current market data
            
        Returns:
            True if analysis should proceed
        """
        # Check if strategy is enabled
        if not self.enabled:
            return False
        
        # Check state
        if self.state == StrategyState.STOPPED:
            return False
        
        # Check cooldown
        last_analysis = self._last_analysis_time.get(token_address)
        if last_analysis:
            if datetime.now() - last_analysis < self._analysis_cooldown:
                return False
        
        # Check if already in position
        if self.config.get("no_duplicate_positions", True):
            if token_address in self.active_positions:
                return False
        
        # Check position limit
        if len(self.active_positions) >= self.max_concurrent_positions:
            return False
        
        # Check volume requirement
        volume = market_data.get("volume", 0)
        if volume < self.min_volume:
            return False
        
        # Check liquidity requirement
        liquidity = market_data.get("liquidity", 0)
        if liquidity < self.min_liquidity:
            return False
        
        return True
    
    def get_performance_summary(self) -> Dict[str, Any]:
        """Get strategy performance summary"""
        return {
            "name": self.name,
            "state": self.state.value,
            "total_trades": self.performance.total_trades,
            "win_rate": f"{self.performance.win_rate * 100:.1f}%",
            "profit_factor": self.performance.profit_factor,
            "total_pnl": self.performance.total_profit - self.performance.total_loss,
            "average_win": self.performance.average_win,
            "average_loss": self.performance.average_loss,
            "sharpe_ratio": self.performance.sharpe_ratio,
            "max_drawdown": f"{self.performance.max_drawdown * 100:.1f}%",
            "active_positions": len(self.active_positions),
            "current_streak": self.performance.current_streak
        }
    
    def calculate_sharpe_ratio(
        self,
        returns: List[float],
        risk_free_rate: float = 0.02
    ) -> float:
        """Calculate Sharpe ratio"""
        if not returns or len(returns) < 2:
            return 0.0
        
        returns_array = np.array(returns)
        excess_returns = returns_array - (risk_free_rate / 252)  # Daily risk-free rate
        
        if np.std(excess_returns) == 0:
            return 0.0
        
        sharpe = np.mean(excess_returns) / np.std(excess_returns)
        return float(sharpe * np.sqrt(252))  # Annualized
    
    def calculate_max_drawdown(self, equity_curve: List[float]) -> float:
        """Calculate maximum drawdown"""
        if not equity_curve:
            return 0.0
        
        peak = equity_curve[0]
        max_dd = 0.0
        
        for value in equity_curve:
            if value > peak:
                peak = value
            
            drawdown = (peak - value) / peak if peak != 0 else 0
            max_dd = max(max_dd, drawdown)
        
        return max_dd
    
    async def backtest(
        self,
        historical_data: List[Dict[str, Any]],
        initial_balance: Decimal = Decimal("10000")
    ) -> Dict[str, Any]:
        """
        Backtest strategy on historical data
        
        Args:
            historical_data: Historical market data
            initial_balance: Starting balance
            
        Returns:
            Backtest results
        """
        logger.info(f"Starting backtest for {self.name}")
        
        # Reset performance
        self.performance = StrategyPerformance()
        self.active_positions.clear()
        self.signal_history.clear()
        self.trade_history.clear()
        
        balance = initial_balance
        equity_curve = [float(balance)]
        returns = []
        
        for i, data in enumerate(historical_data):
            # Skip if not enough data for lookback
            if i < self.lookback_period:
                continue
            
            # Get historical window
            window = historical_data[i - self.lookback_period:i + 1]
            
            # Check for exit signals
            for token, position in list(self.active_positions.items()):
                exit_signal = await self.check_exit_conditions(position, data)
                if exit_signal:
                    # Calculate P&L
                    exit_price = Decimal(str(data["price"]))
                    pnl = position.position_size * calculate_percentage_change(
                        position.entry_price, exit_price
                    ) / Decimal("100")
                    
                    balance += pnl
                    await self._on_position_closed(position, exit_price, "backtest")
            
            # Check for entry signals
            if self.should_analyze(data.get("token_address", ""), data):
                signal = await self.analyze(data)
                
                if signal and self.validate_signal(signal, data):
                    # Calculate position size
                    signal.position_size = self.calculate_position_size(
                        signal,
                        balance,
                        Decimal(str(data["price"]))
                    )
                    
                    if signal.position_size > 0:
                        # Set stop loss and take profit
                        signal.stop_loss = self.calculate_stop_loss(
                            signal.entry_price,
                            signal
                        )
                        signal.target_price = self.calculate_take_profit(
                            signal.entry_price,
                            signal
                        )
                        
                        # "Execute" trade
                        balance -= signal.position_size
                        self.active_positions[signal.token_address] = signal
                        self.signal_history.append(signal)
            
            # Update equity curve
            equity_curve.append(float(balance))
            if len(equity_curve) > 1:
                daily_return = (equity_curve[-1] - equity_curve[-2]) / equity_curve[-2]
                returns.append(daily_return)
        
        # Close remaining positions
        for token, position in self.active_positions.items():
            exit_price = Decimal(str(historical_data[-1]["price"]))
            pnl = position.position_size * calculate_percentage_change(
                position.entry_price, exit_price
            ) / Decimal("100")
            balance += pnl
        
        # Calculate final metrics
        total_return = (balance - initial_balance) / initial_balance
        self.performance.sharpe_ratio = self.calculate_sharpe_ratio(returns)
        self.performance.max_drawdown = self.calculate_max_drawdown(equity_curve)
        
        return {
            "strategy": self.name,
            "initial_balance": initial_balance,
            "final_balance": balance,
            "total_return": f"{total_return * 100:.2f}%",
            "total_trades": self.performance.total_trades,
            "win_rate": f"{self.performance.win_rate * 100:.1f}%",
            "profit_factor": self.performance.profit_factor,
            "sharpe_ratio": self.performance.sharpe_ratio,
            "max_drawdown": f"{self.performance.max_drawdown * 100:.1f}%",
            "equity_curve": equity_curve,
            "trade_history": self.trade_history
        }
    
    def reset(self) -> None:
        """Reset strategy state"""
        self.state = StrategyState.IDLE
        self.active_positions.clear()
        self._last_analysis_time.clear()
        self._position_entry_times.clear()
        logger.info(f"Strategy {self.name} reset")
    
    def stop(self) -> None:
        """Stop strategy"""
        self.state = StrategyState.STOPPED
        logger.info(f"Strategy {self.name} stopped")
    
    def start(self) -> None:
        """Start strategy"""
        self.state = StrategyState.IDLE
        self.enabled = True
        logger.info(f"Strategy {self.name} started")
    
    def get_active_positions(self) -> List[TradingSignal]:
        """Get list of active positions"""
        return list(self.active_positions.values())
    
    def get_signal_history(
        self,
        limit: Optional[int] = None
    ) -> List[TradingSignal]:
        """Get signal history"""
        if limit:
            return self.signal_history[-limit:]
        return self.signal_history
    
    def get_trade_history(
        self,
        limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """Get trade history"""
        if limit:
            return self.trade_history[-limit:]
        return self.trade_history
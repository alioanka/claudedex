{% extends "base.html" %}

{% block title %}Dashboard - DexScreener Trading Bot{% endblock %}

{% block content %}
<div class="page-header">
    <h1>Dashboard Overview</h1>
    <div class="page-actions">
        <button class="btn btn-secondary" onclick="refreshDashboard()">
            <i class="fas fa-sync"></i> Refresh
        </button>
        <button class="btn btn-primary" onclick="window.location.href='/reports'">
            <i class="fas fa-file-download"></i> Generate Report
        </button>
    </div>
</div>

<!-- Key Metrics -->
<div class="grid grid-4">
    <div class="stat-card">
        <i class="fas fa-wallet stat-icon"></i>
        <div class="stat-label">Portfolio Value</div>
        <div class="stat-value" id="portfolioValueStat">$0.00</div>
        <div class="stat-change positive" id="portfolioChange">
            <i class="fas fa-arrow-up"></i> 0.00%
        </div>
    </div>
    
    <div class="stat-card success">
        <i class="fas fa-chart-line stat-icon"></i>
        <div class="stat-label">Total P&L</div>
        <div class="stat-value" id="totalPnlStat">$0.00</div>
        <div class="stat-change positive" id="pnlChange">
            <i class="fas fa-arrow-up"></i> 0.00%
        </div>
    </div>
    
    <div class="stat-card">
        <i class="fas fa-exchange-alt stat-icon"></i>
        <div class="stat-label">Open Positions</div>
        <div class="stat-value" id="openPositionsStat">0</div>
        <div class="stat-change" id="positionsChange">
            Active trades
        </div>
    </div>
    
    <div class="stat-card warning">
        <i class="fas fa-percentage stat-icon"></i>
        <div class="stat-label">Win Rate</div>
        <div class="stat-value" id="winRateStat">0%</div>
        <div class="stat-change" id="winRateChange">
            From trades
        </div>
    </div>
</div>

<!-- Trading Block Status -->
<div class="card" id="blockStatusCard" style="margin-bottom: 20px;">
    <div class="card-header">
        <h3 class="card-title">
            <i class="fas fa-shield-alt"></i>
            Trading Status
        </h3>
        <div class="card-actions">
            <button class="btn btn-sm btn-warning" onclick="reconcileDexPositions()" title="Close stale positions older than 7 days">
                <i class="fas fa-broom"></i> Reconcile P&L
            </button>
            <button class="btn btn-sm btn-secondary" onclick="refreshBlockStatus()">
                <i class="fas fa-sync"></i> Refresh
            </button>
        </div>
    </div>
    <div class="card-body">
        <div id="blockStatusContent">
            <div class="text-center text-muted">
                <i class="fas fa-spinner fa-spin"></i> Loading status...
            </div>
        </div>
    </div>
</div>

<!-- Multi-Wallet Balances -->
<div class="card">
    <div class="card-header">
        <h3 class="card-title">
            <i class="fas fa-coins"></i>
            Wallet Balances by Chain
        </h3>
        <div class="card-actions">
            <button class="btn btn-sm btn-secondary" onclick="refreshBalances()">
                <i class="fas fa-sync"></i> Refresh
            </button>
        </div>
    </div>
    <div class="card-body">
        <div class="grid grid-4" id="chainBalances">
            <!-- Ethereum -->
            <div class="balance-card">
                <div class="balance-header">
                    <span class="chain-icon">
                        <i class="fab fa-ethereum"></i>
                    </span>
                    <span class="chain-name">Ethereum</span>
                </div>
                <div class="balance-value" id="eth-balance">$0.00</div>
                <div class="balance-stats">
                    <div class="balance-stat">
                        <span class="label">P&L:</span>
                        <span class="value" id="eth-pnl">$0.00</span>
                    </div>
                    <div class="balance-stat">
                        <span class="label">Positions:</span>
                        <span class="value" id="eth-positions">0</span>
                    </div>
                </div>
            </div>

            <!-- BSC -->
            <div class="balance-card">
                <div class="balance-header">
                    <span class="chain-icon" style="background: #F3BA2F;">
                        <i class="fas fa-coins"></i>
                    </span>
                    <span class="chain-name">BSC</span>
                </div>
                <div class="balance-value" id="bsc-balance">$0.00</div>
                <div class="balance-stats">
                    <div class="balance-stat">
                        <span class="label">P&L:</span>
                        <span class="value" id="bsc-pnl">$0.00</span>
                    </div>
                    <div class="balance-stat">
                        <span class="label">Positions:</span>
                        <span class="value" id="bsc-positions">0</span>
                    </div>
                </div>
            </div>

            <!-- Arbitrum -->
            <div class="balance-card">
                <div class="balance-header">
                    <span class="chain-icon" style="background: #28A0F0;">
                        <i class="fas fa-bolt"></i>
                    </span>
                    <span class="chain-name">Arbitrum</span>
                </div>
                <div class="balance-value" id="arbitrum-balance">$0.00</div>
                <div class="balance-stats">
                    <div class="balance-stat">
                        <span class="label">P&L:</span>
                        <span class="value" id="arbitrum-pnl">$0.00</span>
                    </div>
                    <div class="balance-stat">
                        <span class="label">Positions:</span>
                        <span class="value" id="arbitrum-positions">0</span>
                    </div>
                </div>
            </div>

            <!-- Base -->
            <div class="balance-card">
                <div class="balance-header">
                    <span class="chain-icon" style="background: #0052FF;">
                        <i class="fas fa-layer-group"></i>
                    </span>
                    <span class="chain-name">Base</span>
                </div>
                <div class="balance-value" id="base-balance">$0.00</div>
                <div class="balance-stats">
                    <div class="balance-stat">
                        <span class="label">P&L:</span>
                        <span class="value" id="base-pnl">$0.00</span>
                    </div>
                    <div class="balance-stat">
                        <span class="label">Positions:</span>
                        <span class="value" id="base-positions">0</span>
                    </div>
                </div>
            </div>

            <!-- Solana -->
            <div class="balance-card">
                <div class="balance-header">
                    <span class="chain-icon" style="background: linear-gradient(90deg, #9945FF, #14F195);">
                        <i class="fas fa-bolt"></i>
                    </span>
                    <span class="chain-name">Solana</span>
                </div>
                <div class="balance-value" id="solana-balance">$0.00</div>
                <div class="balance-stats">
                    <div class="balance-stat">
                        <span class="label">P&L:</span>
                        <span class="value" id="solana-pnl">$0.00</span>
                    </div>
                    <div class="balance-stat">
                        <span class="label">Positions:</span>
                        <span class="value" id="solana-positions">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Charts Row -->
<div class="grid grid-2">
    <!-- Portfolio Value Chart -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-chart-area"></i>
                Portfolio Value
            </h3>
            <div class="card-actions">
                <select id="portfolioTimeframe" class="form-control" style="width: auto;">
                    <option value="1h">1 Hour</option>
                    <option value="24h" selected>24 Hours</option>
                    <option value="7d">7 Days</option>
                    <option value="30d">30 Days</option>
                </select>
            </div>
        </div>
        <div class="card-body">
            <canvas id="portfolioChart" height="300"></canvas>
        </div>
    </div>
    
    <!-- P&L Chart -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-chart-line"></i>
                Profit & Loss
            </h3>
            <div class="card-actions">
                <select id="pnlTimeframe" class="form-control" style="width: auto;">
                    <option value="1h">1 Hour</option>
                    <option value="24h" selected>24 Hours</option>
                    <option value="7d">7 Days</option>
                    <option value="30d">30 Days</option>
                </select>
            </div>
        </div>
        <div class="card-body">
            <canvas id="pnlChart" height="300"></canvas>
        </div>
    </div>
</div>

<!-- Recent Positions & Orders -->
<div class="grid grid-1">
    <!-- Recent Positions -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-wallet"></i>
                Open Positions
            </h3>
            <div class="card-actions">
                <a href="/positions" class="btn btn-sm btn-secondary">View All</a>
            </div>
        </div>
        <div class="card-body">
            <div class="table-container">
                <table id="positionsTable">
                    <thead>
                        <tr>
                            <th>Token</th>
                            <th>Entry</th>
                            <th>Current</th>
                            <th>Amount</th>
                            <th>P&L</th>
                            <th>Status</th>
                            <th>Network</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="8" class="text-center text-muted">
                                Loading positions...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Recent Orders -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-list"></i>
                Recent Orders
            </h3>
            <div class="card-actions">
                <a href="/trades" class="btn btn-sm btn-secondary">View All</a>
            </div>
        </div>
        <div class="card-body">
            <div class="table-container">
                <table id="ordersTable">
                    <thead>
                        <tr>
                            <th>Token</th>
                            <th>Side</th>
                            <th>Type</th>
                            <th>Price</th>
                            <th>Amount</th>
                            <th>P&L</th>
                            <th>Status</th>
                            <th>Network</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="9" class="text-center text-muted">
                                Loading orders...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<!-- Performance Metrics -->
<div class="grid grid-3">
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-chart-pie"></i>
                Win Rate
            </h3>
        </div>
        <div class="card-body">
            <canvas id="winRateChart" height="200"></canvas>
        </div>
    </div>
    
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-tachometer-alt"></i>
                Risk Metrics
            </h3>
        </div>
        <div class="card-body">
            <div class="metric-row">
                <span class="metric-label">Sharpe Ratio</span>
                <span class="metric-value" id="sharpeRatio">0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Max Drawdown</span>
                <span class="metric-value text-danger" id="maxDrawdown">0.00%</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">VaR (95%)</span>
                <span class="metric-value" id="var95">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Portfolio Beta</span>
                <span class="metric-value" id="portfolioBeta">0.00</span>
            </div>
        </div>
    </div>
    
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-chart-bar"></i>
                Trading Stats
            </h3>
        </div>
        <div class="card-body">
            <div class="metric-row">
                <span class="metric-label">Total Trades</span>
                <span class="metric-value" id="totalTrades">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Win Rate</span>
                <span class="metric-value text-success" id="winRate">0%</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Avg Win</span>
                <span class="metric-value text-success" id="avgWin">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Avg Loss</span>
                <span class="metric-value text-danger" id="avgLoss">$0.00</span>
            </div>
        </div>
    </div>
</div>

<!-- Insights Section -->
<div class="card">
    <div class="card-header">
        <h3 class="card-title">Performance Insights</h3>
    </div>
    <div class="card-body">
        <ul id="insightsList">
            <!-- Insights will be loaded here -->
        </ul>
    </div>
</div>

<!-- ML Model Training Section -->
<div class="card" id="mlTrainingCard">
    <div class="card-header">
        <h3 class="card-title">
            <i class="fas fa-brain"></i>
            AI/ML Model Training
        </h3>
        <div class="card-actions">
            <button class="btn btn-sm btn-secondary" onclick="loadMLStatus()">
                <i class="fas fa-sync"></i> Refresh
            </button>
        </div>
    </div>
    <div class="card-body">
        <!-- ML Status Info -->
        <div class="ml-status-grid">
            <div class="ml-status-item">
                <div class="ml-status-label">Training Status</div>
                <div class="ml-status-value" id="mlTrainingStatus">
                    <span class="badge badge-secondary">Not Started</span>
                </div>
            </div>
            <div class="ml-status-item">
                <div class="ml-status-label">Last Training</div>
                <div class="ml-status-value" id="mlLastTraining">Never</div>
            </div>
            <div class="ml-status-item">
                <div class="ml-status-label">Models Available</div>
                <div class="ml-status-value" id="mlModelsCount">0/3</div>
            </div>
            <div class="ml-status-item">
                <div class="ml-status-label">Feature Scaler</div>
                <div class="ml-status-value" id="mlScalerStatus">
                    <span class="badge badge-danger">Not Ready</span>
                </div>
            </div>
        </div>

        <!-- Model Details -->
        <div class="ml-models-section">
            <h4 class="section-subtitle">Available Models</h4>
            <div class="ml-models-grid" id="mlModelsList">
                <div class="ml-model-item">
                    <div class="model-icon"><i class="fas fa-tree"></i></div>
                    <div class="model-info">
                        <div class="model-name">XGBoost</div>
                        <div class="model-status" id="model-xgboost">Not Trained</div>
                    </div>
                </div>
                <div class="ml-model-item">
                    <div class="model-icon"><i class="fas fa-bolt"></i></div>
                    <div class="model-info">
                        <div class="model-name">LightGBM</div>
                        <div class="model-status" id="model-lightgbm">Not Trained</div>
                    </div>
                </div>
                <div class="ml-model-item">
                    <div class="model-icon"><i class="fas fa-sitemap"></i></div>
                    <div class="model-info">
                        <div class="model-name">Random Forest</div>
                        <div class="model-status" id="model-random_forest">Not Trained</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Training Metrics -->
        <div class="ml-metrics-section" id="mlMetricsSection" style="display: none;">
            <h4 class="section-subtitle">Training Metrics</h4>
            <div class="ml-metrics-grid" id="mlMetricsGrid">
                <!-- Metrics will be loaded here -->
            </div>
        </div>

        <!-- Training Controls -->
        <div class="ml-training-controls">
            <div class="training-options">
                <div class="form-group">
                    <label>Min Trades Required</label>
                    <input type="number" id="mlMinTrades" value="100" min="50" max="1000" class="form-control">
                </div>
                <div class="form-group">
                    <label>Lookback Days</label>
                    <input type="number" id="mlLookbackDays" value="30" min="7" max="365" class="form-control">
                </div>
            </div>
            <div class="training-actions">
                <button class="btn btn-primary btn-lg" onclick="startMLTraining()" id="mlTrainBtn">
                    <i class="fas fa-play"></i> Start Training
                </button>
                <p class="training-note">
                    <i class="fas fa-info-circle"></i>
                    Training uses historical trade data to improve AI strategy predictions.
                    If insufficient data, synthetic data will be generated.
                </p>
            </div>
        </div>

        <!-- Training Progress -->
        <div class="ml-training-progress" id="mlTrainingProgress" style="display: none;">
            <div class="progress-header">
                <span>Training in Progress...</span>
                <span id="mlProgressPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="mlProgressBar" style="width: 0%"></div>
            </div>
            <div class="progress-status" id="mlProgressStatus">Initializing...</div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
.page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-xl);
}

.page-actions {
    display: flex;
    gap: var(--spacing-md);
}

.metric-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) 0;
    border-bottom: 1px solid var(--border-color);
}

.metric-row:last-child {
    border-bottom: none;
}

.metric-label {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

.metric-value {
    font-weight: 600;
    font-size: 1rem;
}

.notification-item {
    display: flex;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background-color: var(--bg-tertiary);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-sm);
}

.notification-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.notification-icon.info {
    background-color: rgba(6, 182, 212, 0.2);
    color: var(--accent-info);
}

.notification-icon.warning {
    background-color: rgba(245, 158, 11, 0.2);
    color: var(--accent-warning);
}

.notification-icon.error {
    background-color: rgba(239, 68, 68, 0.2);
    color: var(--accent-danger);
}

.notification-content {
    flex: 1;
}

.notification-title {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
}

.notification-message {
    font-size: 0.875rem;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-xs);
}

.notification-time {
    font-size: 0.75rem;
    color: var(--text-muted);
}

/* Block Status Styles */
.block-status-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.block-status-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    border-radius: 8px;
    background: var(--bg-tertiary);
}

.block-status-header.can-trade {
    border-left: 4px solid #10b981;
}

.block-status-header.blocked {
    border-left: 4px solid #ef4444;
}

.block-status-header.standalone {
    border-left: 4px solid #f59e0b;
    background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), var(--bg-tertiary));
}

.status-icon.warning {
    background: linear-gradient(135deg, #f59e0b, #d97706);
}

.status-value.warning {
    color: #f59e0b;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 12px;
}

.status-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
}

.status-icon.success {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
}

.status-icon.danger {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
}

.status-text {
    display: flex;
    flex-direction: column;
}

.status-label {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.status-value {
    font-size: 1.25rem;
    font-weight: 600;
}

.status-value.success {
    color: #10b981;
}

.status-value.danger {
    color: #ef4444;
}

.block-reasons {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: 8px;
    padding: 16px;
}

.block-reasons-title {
    font-weight: 600;
    color: #ef4444;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.block-reasons-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.block-reasons-list li {
    padding: 8px 0;
    border-bottom: 1px solid rgba(239, 68, 68, 0.2);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}

.block-reasons-list li:last-child {
    border-bottom: none;
}

.block-reasons-list li i {
    color: #ef4444;
}

.block-details {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
    margin-top: 16px;
    padding: 16px;
    background: var(--bg-tertiary);
    border-radius: 8px;
}

.block-detail-item {
    display: flex;
    justify-content: space-between;
    padding: 8px;
    background: var(--bg-secondary);
    border-radius: 6px;
}

.block-detail-label {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

.block-detail-value {
    font-weight: 600;
    color: var(--text-primary);
}

.reset-block-btn {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: #ffffff;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s;
}

.reset-block-btn:hover {
    background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
}

.reset-block-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* ML Training Section Styles */
.ml-status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 16px;
    margin-bottom: 24px;
}

.ml-status-item {
    background: var(--bg-tertiary);
    border-radius: 8px;
    padding: 16px;
    text-align: center;
}

.ml-status-label {
    font-size: 0.75rem;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
}

.ml-status-value {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
}

.section-subtitle {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.ml-models-section {
    margin-bottom: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border-color);
}

.ml-models-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
}

.ml-model-item {
    display: flex;
    align-items: center;
    gap: 12px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    padding: 12px 16px;
    transition: all 0.3s;
}

.ml-model-item:hover {
    background: var(--bg-secondary);
}

.ml-model-item.trained {
    border-left: 3px solid #10b981;
}

.model-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    background: rgba(59, 130, 246, 0.2);
    color: #3b82f6;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
}

.model-info {
    flex: 1;
}

.model-name {
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 2px;
}

.model-status {
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.model-status.trained {
    color: #10b981;
}

.ml-metrics-section {
    margin-bottom: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border-color);
}

.ml-metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 12px;
}

.ml-metric-item {
    background: var(--bg-tertiary);
    border-radius: 8px;
    padding: 12px;
    text-align: center;
}

.ml-metric-label {
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

.ml-metric-value {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--accent-primary);
}

.ml-training-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 24px;
    align-items: flex-start;
    padding-top: 16px;
    border-top: 1px solid var(--border-color);
}

.training-options {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
}

.training-options .form-group {
    min-width: 150px;
}

.training-options label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 4px;
    display: block;
}

.training-options input {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 0.9rem;
}

.training-actions {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: flex-end;
}

.training-note {
    font-size: 0.8rem;
    color: var(--text-secondary);
    max-width: 400px;
    text-align: right;
}

.training-note i {
    color: #3b82f6;
}

.btn-lg {
    padding: 12px 24px;
    font-size: 1rem;
}

.ml-training-progress {
    margin-top: 24px;
    padding: 16px;
    background: var(--bg-tertiary);
    border-radius: 8px;
}

.progress-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 0.9rem;
}

.progress-bar {
    height: 8px;
    background: var(--bg-secondary);
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #10b981);
    border-radius: 4px;
    transition: width 0.5s ease;
}

.progress-status {
    margin-top: 8px;
    font-size: 0.8rem;
    color: var(--text-secondary);
}
</style>
{% endblock %}

{% block extra_js %}
<script>
// ========================================
// BLOCK STATUS MANAGEMENT
// ========================================

async function loadBlockStatus() {
    try {
        const response = await fetch('/api/portfolio/block-status');
        const data = await response.json();

        if (data.success) {
            renderBlockStatus(data.data);
        } else {
            document.getElementById('blockStatusContent').innerHTML = `
                <div class="text-center text-danger">
                    <i class="fas fa-exclamation-triangle"></i> Failed to load status: ${data.error}
                </div>
            `;
        }
    } catch (error) {
        console.error('Error loading block status:', error);
        document.getElementById('blockStatusContent').innerHTML = `
            <div class="text-center text-muted">
                <i class="fas fa-info-circle"></i> Block status unavailable (API not connected)
            </div>
        `;
    }
}

function renderBlockStatus(data) {
    const container = document.getElementById('blockStatusContent');
    const canTrade = data.can_trade;
    const reasons = data.reasons || [];
    const moduleStatus = data.module_status || 'unknown';
    const isStandalone = moduleStatus === 'standalone' || moduleStatus === 'offline';

    let html = '<div class="block-status-container">';

    // Determine status style and text
    let statusClass, iconClass, statusText;
    if (canTrade) {
        statusClass = 'can-trade';
        iconClass = 'success';
        statusText = 'Active - Can Trade';
    } else if (isStandalone) {
        statusClass = 'standalone';
        iconClass = 'warning';
        statusText = 'Standalone Dashboard - Historical Data Only';
    } else {
        statusClass = 'blocked';
        iconClass = 'danger';
        statusText = 'Blocked - Cannot Trade';
    }

    // Status Header
    html += `
        <div class="block-status-header ${statusClass}">
            <div class="status-indicator">
                <div class="status-icon ${iconClass}">
                    <i class="fas fa-${canTrade ? 'check' : (isStandalone ? 'database' : 'ban')}"></i>
                </div>
                <div class="status-text">
                    <span class="status-label">Trading Status</span>
                    <span class="status-value ${iconClass}">
                        ${statusText}
                    </span>
                </div>
            </div>
            ${!canTrade && !isStandalone ? `
                <button class="reset-block-btn" onclick="resetTradingBlock()">
                    <i class="fas fa-unlock"></i>
                    Reset Block
                </button>
            ` : ''}
        </div>
    `;

    // Block Reasons (if blocked)
    if (!canTrade && reasons.length > 0) {
        html += `
            <div class="block-reasons">
                <div class="block-reasons-title">
                    <i class="fas fa-exclamation-circle"></i>
                    Blocking Reasons
                </div>
                <ul class="block-reasons-list">
                    ${reasons.map(reason => `
                        <li>
                            <i class="fas fa-times-circle"></i>
                            ${reason}
                        </li>
                    `).join('')}
                </ul>
            </div>
        `;
    }

    // Details Grid
    html += `
        <div class="block-details">
            <div class="block-detail-item">
                <span class="block-detail-label">Balance</span>
                <span class="block-detail-value">$${(data.balance || 0).toFixed(2)}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Available</span>
                <span class="block-detail-value">$${(data.available_balance || 0).toFixed(2)}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Min Position</span>
                <span class="block-detail-value">$${(data.min_position_size || 5).toFixed(2)}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Positions</span>
                <span class="block-detail-value">${data.positions_count || 0} / ${data.max_positions || 10}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Consecutive Losses</span>
                <span class="block-detail-value ${(data.consecutive_losses || 0) >= 4 ? 'text-danger' : ''}">${data.consecutive_losses || 0}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Lifetime Blocks</span>
                <span class="block-detail-value">${data.consecutive_losses_block_count || 0}</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Risk Exposure</span>
                <span class="block-detail-value">${((data.risk_exposure || 0) * 100).toFixed(1)}%</span>
            </div>
            <div class="block-detail-item">
                <span class="block-detail-label">Max Risk</span>
                <span class="block-detail-value">${((data.max_portfolio_risk || 0.25) * 100).toFixed(0)}%</span>
            </div>
        </div>
    `;

    // Block duration info - show when blocked
    if (!canTrade && (data.block_remaining_hours > 0 || data.consecutive_losses_blocked_at || data.daily_loss_blocked_at)) {
        let blockedSince = data.consecutive_losses_blocked_at || data.daily_loss_blocked_at;
        let blockDurationHours = 0;

        if (blockedSince) {
            const blockedSinceDate = new Date(blockedSince);
            blockDurationHours = (Date.now() - blockedSinceDate.getTime()) / (1000 * 60 * 60);
        }

        html += `
            <div class="block-reasons" style="background: rgba(245, 158, 11, 0.1); border-color: rgba(245, 158, 11, 0.3);">
                <div class="block-reasons-title" style="color: #f59e0b;">
                    <i class="fas fa-clock"></i>
                    Block Duration
                </div>
                <div style="color: var(--text-primary);">
                    ${blockedSince ? `<p style="margin: 0 0 8px 0;">Blocked since: <strong>${new Date(blockedSince).toLocaleString()}</strong> (${blockDurationHours.toFixed(1)} hours ago)</p>` : ''}
                    ${data.block_remaining_hours > 0 ? `<p style="margin: 0;">Remaining: <strong>${data.block_remaining_hours.toFixed(1)} more hours</strong>${data.blocked_until ? ` (until ${new Date(data.blocked_until).toLocaleTimeString()})` : ''}</p>` : ''}
                </div>
            </div>
        `;
    }

    html += '</div>';
    container.innerHTML = html;
}

async function resetTradingBlock() {
    if (!confirm('Are you sure you want to reset the trading block?\n\nThis will:\n- Clear consecutive losses counter\n- Remove any active time-based blocks\n\nNote: If the block is due to low balance, you need to add funds instead.')) {
        return;
    }

    const reason = prompt('Enter reason for reset (optional):', 'Manual reset via dashboard');
    if (reason === null) return; // User cancelled

    try {
        showToast('info', 'Resetting trading block...');

        const response = await fetch('/api/portfolio/reset-block', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ reason: reason || 'Manual reset via dashboard' })
        });

        const data = await response.json();

        if (data.success) {
            showToast('success', data.message || 'Trading block reset successfully');
            // Reload block status
            setTimeout(loadBlockStatus, 500);
        } else {
            showToast('error', data.error || 'Failed to reset block');
        }
    } catch (error) {
        console.error('Error resetting block:', error);
        showToast('error', 'Failed to reset block: ' + error.message);
    }
}

function refreshBlockStatus() {
    const content = document.getElementById('blockStatusContent');
    content.innerHTML = '<div class="text-center text-muted"><i class="fas fa-spinner fa-spin"></i> Refreshing...</div>';
    loadBlockStatus();
}

// Reconcile stale DEX positions
async function reconcileDexPositions() {
    if (!confirm('This will close stale positions older than 7 days with estimated P&L.\n\nActive positions will be preserved.\n\nContinue?')) {
        return;
    }

    try {
        showToast('info', 'Reconciling stale positions...');
        const response = await apiPost('/api/dex/reconcile', {});

        if (response.success) {
            const stats = response.stats || {};
            showToast('success', `Reconciled ${stats.positions_closed || 0} positions. P&L: $${(stats.total_estimated_pnl || 0).toFixed(2)}`);
            // Refresh the block status and positions
            refreshBlockStatus();
            loadOpenPositions();
        } else {
            showToast('error', response.error || 'Failed to reconcile');
        }
    } catch (error) {
        console.error('Error reconciling:', error);
        showToast('error', 'Failed to reconcile: ' + error.message);
    }
}

// Dashboard-specific JavaScript
async function refreshDashboard() {
    showToast('info', 'Refreshing dashboard...');
    await loadDashboardData();
    await loadCharts();
    showToast('success', 'Dashboard refreshed');
}

async function loadCharts() {
    // Load portfolio chart
    loadPortfolioChart();
    
    // Load P&L chart
    loadPnLChart();
    
    // Load win rate chart
    loadWinRateChart();
}

async function loadPortfolioChart() {
    const timeframe = document.getElementById('portfolioTimeframe').value;
    
    try {
        const response = await apiGet(`/api/performance/charts?timeframe=${timeframe}`);
        
        if (response.success && response.data.portfolio_history && response.data.portfolio_history.length > 0) {
            const data = response.data.portfolio_history;
            
            // ✅ Format labels based on timeframe
            const formatLabel = (timestamp) => {
                const date = new Date(timestamp);
                if (timeframe === '7d' || timeframe === '30d') {
                    return date.toLocaleDateString(); // Show date for longer timeframes
                } else {
                    return date.toLocaleTimeString(); // Show time for 1h/24h
                }
            };
            
            createChart('portfolioChart', {
                type: 'line',
                data: {
                    labels: data.map(d => formatLabel(d.timestamp)),
                    datasets: [{
                        label: 'Portfolio Value',
                        data: data.map(d => d.value),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { callback: value => formatCurrency(value) }
                        }
                    }
                }
            });
        }
    } catch (error) {
        console.error('Error loading portfolio chart:', error);
    }
}

async function loadPnLChart() {
    const timeframe = document.getElementById('pnlTimeframe').value;
    
    try {
        const response = await apiGet(`/api/performance/charts?timeframe=${timeframe}`);
        
        if (response.success && response.data.pnl_history && response.data.pnl_history.length > 0) {
            const data = response.data.pnl_history;
            
            createChart('pnlChart', {
                type: 'bar',
                data: {
                    labels: data.map(d => formatDate(d.timestamp)),
                    datasets: [{
                        label: 'P&L',
                        data: data.map(d => d.value),
                        backgroundColor: data.map(d => d.value >= 0 ? 
                            'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)')
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => formatCurrency(value)
                            }
                        }
                    }
                }
            });
        } else {
            // ✅ Show "No data" message
            const canvas = document.getElementById('pnlChart');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '16px Arial';
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';
                ctx.fillText('No data available for this timeframe', canvas.width / 2, canvas.height / 2);
            }
        }
    } catch (error) {
        console.error('Error loading P&L chart:', error);
    }
}

async function loadWinRateChart() {
    try {
        const response = await apiGet('/api/performance/metrics');
        
        if (response.success && response.data) {
            const historical = response.data.historical || {};
            const winningTrades = historical.winning_trades || 0;
            const losingTrades = historical.losing_trades || 0;
            const totalTrades = winningTrades + losingTrades;
            
            // Update stats
            document.getElementById('totalTrades').textContent = historical.total_trades || 0;
            document.getElementById('winRate').textContent = `${(historical.win_rate || 0).toFixed(2)}%`;
            document.getElementById('avgWin').textContent = formatCurrency(historical.avg_win || 0);
            document.getElementById('avgLoss').textContent = formatCurrency(historical.avg_loss || 0);
            document.getElementById('totalPnlStat').textContent = formatCurrency(historical.total_pnl || 0);
            document.getElementById('winRateStat').textContent = `${(historical.win_rate || 0).toFixed(1)}%`;
            
            // ✅ Destroy existing chart first
            const ctx = document.getElementById('winRateChart');
            if (!ctx) return;
            
            // Get existing chart instance
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // ✅ FIX: Use actual trade counts, not percentages
            const chartData = totalTrades > 0 ? [winningTrades, losingTrades] : [1, 0];
            
            // Create new chart
            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Wins', 'Losses'],
                    datasets: [{
                        data: chartData,
                        backgroundColor: [
                            'rgba(16, 185, 129, 0.8)',
                            'rgba(239, 68, 68, 0.8)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => ({
                                        text: `${label}: ${data.datasets[0].data[i]}`,
                                        fillStyle: data.datasets[0].backgroundColor[i],
                                        hidden: false,
                                        index: i
                                    }));
                                }
                            }
                        }
                    }
                }
            });
        }
    } catch (error) {
        console.error('Error loading win rate chart:', error);
    }
}

// ✅ ADD these new functions (don't remove your existing code)

// Load historical stats ONCE on page load
async function loadHistoricalStats() {
    try {
        const response = await apiGet('/api/performance/metrics');
        
        if (response.success && response.data) {
            const hist = response.data.historical || {};
            const portfolio = response.data || {};
            
            // Update Trading Stats
            document.getElementById('totalTrades').textContent = hist.total_trades || 0;
            document.getElementById('winRate').textContent = `${(hist.win_rate || 0).toFixed(2)}%`;
            document.getElementById('avgWin').textContent = formatCurrency(hist.avg_win || 0);
            document.getElementById('avgLoss').textContent = formatCurrency(hist.avg_loss || 0);
            
            // ✅ Update Portfolio Value and Total P&L with percentages
            const totalPnl = hist.total_pnl || 0;
            const startingBalance = 400;
            const portfolioValue = startingBalance + totalPnl;
            const pnlPercent = (totalPnl / startingBalance) * 100;
            
            document.getElementById('portfolioValueStat').textContent = formatCurrency(portfolioValue);
            document.getElementById('totalPnlStat').textContent = formatCurrency(totalPnl);
            document.getElementById('winRateStat').textContent = `${(hist.win_rate || 0).toFixed(1)}%`;
            
            // ✅ Update percentage indicators
            const portfolioChange = document.getElementById('portfolioChange');
            if (portfolioChange) {
                portfolioChange.className = `stat-change ${pnlPercent >= 0 ? 'positive' : 'negative'}`;
                portfolioChange.innerHTML = `<i class="fas fa-arrow-${pnlPercent >= 0 ? 'up' : 'down'}"></i> ${Math.abs(pnlPercent).toFixed(2)}%`;
            }
            
            const pnlChange = document.getElementById('pnlChange');
            if (pnlChange) {
                pnlChange.className = `stat-change ${pnlPercent >= 0 ? 'positive' : 'negative'}`;
                pnlChange.innerHTML = `<i class="fas fa-arrow-${pnlPercent >= 0 ? 'up' : 'down'}"></i> ${Math.abs(pnlPercent).toFixed(2)}%`;
            }
            
            // Update Risk Metrics
            const sharpeRatio = document.getElementById('sharpeRatio');
            if (sharpeRatio) sharpeRatio.textContent = (hist.sharpe_ratio || 0).toFixed(2);
            
            const maxDrawdown = document.getElementById('maxDrawdown');
            if (maxDrawdown) maxDrawdown.textContent = `${Math.abs(hist.max_drawdown || 0).toFixed(2)}%`;
            
            const var95 = document.getElementById('var95');
            if (var95) var95.textContent = formatCurrency(portfolioValue * 0.05);
            
            const portfolioBeta = document.getElementById('portfolioBeta');
            if (portfolioBeta) portfolioBeta.textContent = (hist.portfolio_beta || 0).toFixed(2);
        }
    } catch (error) {
        console.error('Error loading historical stats:', error);
    }
}

// Load recent trades (handle errors gracefully)
async function loadOrders() {
    try {
        const response = await apiGet('/api/trades/recent?limit=10');
        if (response && response.success && response.data) {
            updateOrdersTable(response.data);
        } else {
            showEmptyOrders();
        }
    } catch (error) {
        console.error('Error loading orders:', error);
        showEmptyOrders();
    }
}

// Load and update open positions count
async function updatePositionsCount() {
    try {
        const response = await apiGet('/api/positions/open');
        if (response && response.success && response.data) {
            const openPositionsStat = document.getElementById('openPositionsStat');
            if (openPositionsStat) {
                openPositionsStat.textContent = response.data.length;
            }
        }
    } catch (error) {
        console.error('Error updating positions count:', error);
    }
}

// Call it when loading positions
async function loadPositions() {
    try {
        const response = await apiGet('/api/positions/open');
        if (response && response.success && response.data) {
            updatePositionsTable(response.data);
            // ✅ Update count
            const openPositionsStat = document.getElementById('openPositionsStat');
            if (openPositionsStat) {
                openPositionsStat.textContent = response.data.length;
            }
        } else {
            showEmptyPositions();
        }
    } catch (error) {
        console.error('Error loading positions:', error);
        showEmptyPositions();
    }
}

// Helper functions
function showEmptyPositions() {
    const tbody = document.querySelector('#positionsTable tbody');
    if (tbody) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No open positions</td></tr>';
    }
}

function showEmptyOrders() {
    const tbody = document.querySelector('#ordersTable tbody');
    if (tbody) {
        tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">No recent trades</td></tr>';
    }
}

// Update positions table
function updatePositionsTable(positions) {
    const tbody = document.querySelector('#positionsTable tbody');
    if (!tbody) return;
    
    if (!positions || positions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">No open positions</td></tr>';
        return;
    }
    
    tbody.innerHTML = positions.map(pos => {
        // ✅ Calculate P&L if not provided
        const entryPrice = pos.entry_price || 0;
        const currentPrice = pos.current_price || entryPrice;
        const amount = pos.amount || 0;
        const entryValue = pos.entry_value || (entryPrice * amount);
        
        // Calculate unrealized P&L
        let unrealizedPnl = pos.unrealized_pnl || 0;
        if (unrealizedPnl === 0 && entryPrice > 0) {
            unrealizedPnl = (currentPrice - entryPrice) * amount;
        }
        
        // Calculate P&L percentage
        const pnlPercent = entryValue > 0 ? ((unrealizedPnl / entryValue) * 100) : 0;
        
        return `
            <tr>
                <td>${pos.token_symbol || 'Unknown'}</td>
                <td>$${entryPrice.toFixed(8)}</td>
                <td>$${currentPrice.toFixed(8)}</td>
                <td>${amount.toFixed(2)}</td>
                <td class="${unrealizedPnl >= 0 ? 'text-success' : 'text-danger'}">
                    ${formatCurrency(unrealizedPnl)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                </td>
                <td><span class="badge badge-success">${pos.status || 'open'}</span></td>
                <td><span class="badge badge-info">${pos.chain ? pos.chain.toUpperCase() : (pos.network ? pos.network.toUpperCase() : 'SOL')}</span></td>
                <td>
                    <button class="btn btn-sm btn-danger" onclick="closePosition('${pos.id}')">
                        Close
                    </button>
                </td>
            </tr>
        `;
    }).join('');
}


async function closePosition(positionId) {
    if (!confirm('Are you sure you want to close this position?')) {
        return;
    }
    
    try {
        showToast('info', 'Closing position...');
        
        const response = await apiPost('/api/position/close', { 
            position_id: positionId 
        });
        
        console.log('Close response:', response);
        
        if (response && response.success) {
            showToast('success', response.message || 'Position closed successfully');
            // Reload positions after 1 second
            setTimeout(async () => {
                await loadPositions();
            }, 1000);
        } else {
            showToast('error', response.error || 'Failed to close position');
        }
    } catch (error) {
        console.error('Error closing position:', error);
        showToast('error', 'Failed to close position: ' + error.message);
    }
}

window.closePosition = closePosition;


// ========================================
// WALLET BALANCES
// ========================================

async function loadWalletBalances() {
    try {
        const response = await fetch('/api/wallets/balances');
        const data = await response.json();
        
        if (data.status === 'success') {
            updateBalanceDisplay(data.balances);
        }
    } catch (error) {
        console.error('Error loading wallet balances:', error);
    }
}

function updateBalanceDisplay(balances) {
    // Update individual chains
    const chains = ['ETHEREUM', 'BSC', 'ARBITRUM', 'BASE', 'SOLANA'];

    chains.forEach(chain => {
        const chainData = balances[chain];
        if (!chainData) return;

        const chainKey = chain.toLowerCase().replace('ethereum', 'eth');
        
        // Update balance
        const balanceEl = document.getElementById(`${chainKey}-balance`);
        if (balanceEl) {
            balanceEl.textContent = `$${chainData.balance.toFixed(2)}`;
        }
        
        // Update P&L
        const pnlEl = document.getElementById(`${chainKey}-pnl`);
        if (pnlEl) {
            const pnl = chainData.pnl || 0;
            pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`;
            pnlEl.className = `value ${pnl >= 0 ? 'positive' : 'negative'}`;
        }
        
        // Update positions count
        const posEl = document.getElementById(`${chainKey}-positions`);
        if (posEl) {
            posEl.textContent = chainData.positions || 0;
        }
    });
    
    // Update total portfolio value (top stat card) - DISABLED TO PREVENT OVERWRITING
    /*
    if (balances.TOTAL) {
        const portfolioEl = document.getElementById('portfolioValueStat');
        if (portfolioEl) {
            portfolioEl.textContent = `$${balances.TOTAL.balance.toFixed(2)}`;
        }
        
        const pnlEl = document.getElementById('totalPnlStat');
        if (pnlEl) {
            const pnl = balances.TOTAL.pnl || 0;
            pnlEl.textContent = `${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`;
        }
    }
    */
}

function refreshBalances() {
    loadWalletBalances();
}

// Auto-refresh balances every 10 seconds
setInterval(loadWalletBalances, 10000);

// Load on page load
document.addEventListener('DOMContentLoaded', function() {
    loadWalletBalances();
});

// Update orders table  
function updateOrdersTable(orders) {
    const tbody = document.querySelector('#ordersTable tbody');
    if (!tbody) return;
    
    if (!orders || orders.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" class="text-center text-muted">No recent orders</td></tr>';
        return;
    }
    
    tbody.innerHTML = orders.slice(0, 5).map(order => {
        let tokenSymbol = 'Unknown';
        try {
            if (order.metadata) {
                const metadata = typeof order.metadata === 'string' 
                    ? JSON.parse(order.metadata) 
                    : order.metadata;
                tokenSymbol = metadata.token_symbol || tokenSymbol;
            }
        } catch (e) {}
        
        // ✅ Calculate P&L
        const pnl = order.profit_loss || 0;
        const pnlPercent = order.profit_loss_percentage || 0;
        const pnlClass = pnl >= 0 ? 'text-success' : 'text-danger';
        const pnlDisplay = order.status === 'closed' 
            ? `${formatCurrency(pnl)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)`
            : '-';
        
        return `
            <tr>
                <td>${tokenSymbol}</td>
                <td><span class="badge badge-${order.side === 'buy' ? 'success' : 'danger'}">${(order.side || 'N/A').toUpperCase()}</span></td>
                <td>Market</td>
                <td>$${(order.entry_price || 0).toFixed(8)}</td>
                <td>${(order.amount || 0).toFixed(2)}</td>
                <td class="${pnlClass}">${pnlDisplay}</td>
                <td><span class="badge badge-${order.status === 'open' ? 'info' : order.status === 'closed' ? 'success' : 'secondary'}">${order.status || 'N/A'}</span></td>
                <td><span class="badge badge-info">${order.chain ? order.chain.toUpperCase() : 'N/A'}</span></td>
                <td>${timeAgo(order.entry_timestamp || Date.now())}</td>
            </tr>
        `;
    }).join('');
}

// ==================== ML Training Functions ====================

let mlTrainingInProgress = false;

async function loadMLStatus() {
    try {
        const response = await fetch('/api/ml/status');
        const result = await response.json();

        if (result.success && result.data) {
            const data = result.data;

            // Update last training time
            const lastTrainingEl = document.getElementById('mlLastTraining');
            if (lastTrainingEl) {
                if (data.last_training) {
                    const date = new Date(data.last_training);
                    lastTrainingEl.textContent = date.toLocaleString();
                } else {
                    lastTrainingEl.textContent = 'Never';
                }
            }

            // Update models count
            const modelsCountEl = document.getElementById('mlModelsCount');
            if (modelsCountEl) {
                const count = data.models_available ? data.models_available.length : 0;
                modelsCountEl.textContent = `${count}/3`;
            }

            // Update scaler status
            const scalerStatusEl = document.getElementById('mlScalerStatus');
            if (scalerStatusEl) {
                if (data.scaler_available) {
                    scalerStatusEl.innerHTML = '<span class="badge badge-success">Ready</span>';
                } else {
                    scalerStatusEl.innerHTML = '<span class="badge badge-danger">Not Ready</span>';
                }
            }

            // Update training status
            const trainingStatusEl = document.getElementById('mlTrainingStatus');
            if (trainingStatusEl) {
                if (mlTrainingInProgress) {
                    trainingStatusEl.innerHTML = '<span class="badge badge-warning">Training...</span>';
                } else if (data.models_available && data.models_available.length > 0) {
                    trainingStatusEl.innerHTML = '<span class="badge badge-success">Trained</span>';
                } else {
                    trainingStatusEl.innerHTML = '<span class="badge badge-secondary">Not Started</span>';
                }
            }

            // Update individual model statuses
            if (data.models_available) {
                const modelNames = ['xgboost', 'lightgbm', 'random_forest'];
                modelNames.forEach(name => {
                    const modelStatusEl = document.getElementById(`model-${name}`);
                    const modelItem = modelStatusEl?.closest('.ml-model-item');
                    const model = data.models_available.find(m => m.name === name);

                    if (modelStatusEl) {
                        if (model) {
                            const modDate = new Date(model.modified);
                            modelStatusEl.textContent = `Trained ${modDate.toLocaleDateString()}`;
                            modelStatusEl.classList.add('trained');
                            if (modelItem) modelItem.classList.add('trained');
                        } else {
                            modelStatusEl.textContent = 'Not Trained';
                            modelStatusEl.classList.remove('trained');
                            if (modelItem) modelItem.classList.remove('trained');
                        }
                    }
                });
            }

            // Update metrics section
            if (data.metrics && Object.keys(data.metrics).length > 0) {
                const metricsSection = document.getElementById('mlMetricsSection');
                const metricsGrid = document.getElementById('mlMetricsGrid');

                if (metricsSection && metricsGrid) {
                    metricsSection.style.display = 'block';
                    metricsGrid.innerHTML = Object.entries(data.metrics).map(([key, value]) => `
                        <div class="ml-metric-item">
                            <div class="ml-metric-label">${key.replace(/_/g, ' ')}</div>
                            <div class="ml-metric-value">${typeof value === 'number' ? value.toFixed(4) : value}</div>
                        </div>
                    `).join('');
                }
            }
        }
    } catch (error) {
        console.error('Error loading ML status:', error);
    }
}

async function startMLTraining() {
    if (mlTrainingInProgress) {
        alert('Training is already in progress');
        return;
    }

    const minTrades = parseInt(document.getElementById('mlMinTrades').value) || 100;
    const lookbackDays = parseInt(document.getElementById('mlLookbackDays').value) || 30;

    const trainBtn = document.getElementById('mlTrainBtn');
    const progressDiv = document.getElementById('mlTrainingProgress');
    const progressBar = document.getElementById('mlProgressBar');
    const progressPercent = document.getElementById('mlProgressPercent');
    const progressStatus = document.getElementById('mlProgressStatus');

    // Update UI
    mlTrainingInProgress = true;
    trainBtn.disabled = true;
    trainBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Training...';
    progressDiv.style.display = 'block';
    progressBar.style.width = '0%';
    progressPercent.textContent = '0%';
    progressStatus.textContent = 'Initializing training...';

    // Simulate progress updates
    let progress = 0;
    const progressInterval = setInterval(() => {
        if (progress < 90) {
            progress += Math.random() * 15;
            progress = Math.min(progress, 90);
            progressBar.style.width = progress + '%';
            progressPercent.textContent = Math.round(progress) + '%';

            if (progress < 20) {
                progressStatus.textContent = 'Loading historical data...';
            } else if (progress < 40) {
                progressStatus.textContent = 'Preparing features...';
            } else if (progress < 60) {
                progressStatus.textContent = 'Training XGBoost model...';
            } else if (progress < 75) {
                progressStatus.textContent = 'Training LightGBM model...';
            } else {
                progressStatus.textContent = 'Training Random Forest model...';
            }
        }
    }, 500);

    try {
        const response = await fetch('/api/ml/train', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                min_trades: minTrades,
                lookback_days: lookbackDays
            })
        });

        clearInterval(progressInterval);
        const result = await response.json();

        if (result.success) {
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            progressStatus.textContent = 'Training completed successfully!';

            // Show success alert with results
            const modelResults = result.data.model_results || {};
            let resultMsg = 'ML Training completed successfully!\n\n';
            Object.entries(modelResults).forEach(([model, metrics]) => {
                if (metrics.accuracy) {
                    resultMsg += `${model}: Accuracy ${(metrics.accuracy * 100).toFixed(1)}%, F1 ${(metrics.f1_score * 100).toFixed(1)}%\n`;
                } else if (metrics.error) {
                    resultMsg += `${model}: Error - ${metrics.error}\n`;
                }
            });
            alert(resultMsg);

            // Reload status
            await loadMLStatus();
        } else {
            progressStatus.textContent = 'Training failed: ' + (result.error || 'Unknown error');
            alert('Training failed: ' + (result.error || 'Unknown error'));
        }
    } catch (error) {
        clearInterval(progressInterval);
        progressStatus.textContent = 'Training failed: ' + error.message;
        alert('Training failed: ' + error.message);
    } finally {
        mlTrainingInProgress = false;
        trainBtn.disabled = false;
        trainBtn.innerHTML = '<i class="fas fa-play"></i> Start Training';

        // Hide progress after 3 seconds
        setTimeout(() => {
            progressDiv.style.display = 'none';
        }, 3000);
    }
}

// ✅ MODIFY your existing DOMContentLoaded to call these functions
document.addEventListener('DOMContentLoaded', function() {
    // ✅ Load everything ONCE on page load
    loadHistoricalStats();
    loadCharts();
    loadPositions();
    loadOrders();
    loadInsights();  // ✅ Load performance insights
    loadBlockStatus();  // ✅ Load trading block status
    loadMLStatus();  // ✅ Load ML model status

    // Add timeframe change listeners (these will reload specific charts)
    document.getElementById('portfolioTimeframe').addEventListener('change', loadPortfolioChart);
    document.getElementById('pnlTimeframe').addEventListener('change', loadPnLChart);

    // Initialize WebSocket
    if (typeof initWebSocket === 'function') {
        initWebSocket();
    }

    // ✅ DON'T call loadCharts() repeatedly - only load once!
    // ✅ Auto-refresh positions and orders every 5 seconds
    // Positions/Orders refresh every 5 seconds
    setInterval(async () => {
        await loadPositions();
        await loadOrders();
    }, 5000);

    // Charts refresh every 15 minutes
    setInterval(async () => {
        await loadPortfolioChart();
        await loadPnLChart();
    }, 900000);  // 15 minutes = 900,000 ms

    // Insights refresh every 30 seconds
    setInterval(async () => {
        await loadInsights();
    }, 30000);  // 30 seconds

    // Block status refresh every 30 seconds
    setInterval(async () => {
        await loadBlockStatus();
    }, 30000);  // 30 seconds

    // ML status refresh every 60 seconds
    setInterval(async () => {
        await loadMLStatus();
    }, 60000);  // 60 seconds

    // ✅ DON'T refresh summary stats - they should only be loaded once
});
</script>
{% endblock %}
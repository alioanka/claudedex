/usr/local/lib/python3.11/site-packages/pytest_benchmark/logger.py:44: PytestBenchmarkWarning: Not saving anything, no benchmarks have been run!
  warner(PytestBenchmarkWarning(text))

==================================== ERRORS ====================================
________________ ERROR collecting scripts/test_solana_setup.py _________________

cls = <class '_pytest.runner.CallInfo'>
func = <function pytest_make_collect_report.<locals>.collect at 0x76f09e4fff60>
when = 'collect', reraise = (<class 'KeyboardInterrupt'>, <class 'SystemExit'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

/usr/local/lib/python3.11/site-packages/_pytest/runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def collect() -> list[Item | Collector]:
        # Before collecting, if this is a Directory, load the conftests.
        # If a conftest import fails to load, it is considered a collection
        # error of the Directory collector. This is why it's done inside of the
        # CallInfo wrapper.
        #
        # Note: initial conftests are loaded early, not here.
        if isinstance(collector, Directory):
            collector.config.pluginmanager._loadconftestmodules(
                collector.path,
                collector.config.getoption("importmode"),
                rootpath=collector.config.rootpath,
                consider_namespace_packages=collector.config.getini(
                    "consider_namespace_packages"
                ),
            )
    
>       return list(collector.collect())
                    ^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/_pytest/runner.py:398: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Module test_solana_setup.py>

    def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
>       self._register_setup_module_fixture()

/usr/local/lib/python3.11/site-packages/_pytest/python.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Module test_solana_setup.py>

    def _register_setup_module_fixture(self) -> None:
        """Register an autouse, module-scoped fixture for the collected module object
        that invokes setUpModule/tearDownModule if either or both are available.
    
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
        other fixtures (#517).
        """
        setup_module = _get_first_non_fixture_func(
>           self.obj, ("setUpModule", "setup_module")
            ^^^^^^^^
        )

/usr/local/lib/python3.11/site-packages/_pytest/python.py:576: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Module test_solana_setup.py>

    @property
    def obj(self):
        """Underlying Python object."""
        obj = getattr(self, "_obj", None)
        if obj is None:
>           self._obj = obj = self._getobj()
                              ^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/_pytest/python.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Module test_solana_setup.py>

    def _getobj(self):
>       return importtestmodule(self.path, self.config)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/_pytest/python.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/app/scripts/test_solana_setup.py')
config = <_pytest.config.Config object at 0x76f09e4646d0>

    def importtestmodule(
        path: Path,
        config: Config,
    ):
        # We assume we are only called once per module.
        importmode = config.getoption("--import-mode")
        try:
>           mod = import_path(
                path,
                mode=importmode,
                root=config.rootpath,
                consider_namespace_packages=config.getini("consider_namespace_packages"),
            )

/usr/local/lib/python3.11/site-packages/_pytest/python.py:507: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/app/scripts/test_solana_setup.py')

    def import_path(
        path: str | os.PathLike[str],
        *,
        mode: str | ImportMode = ImportMode.prepend,
        root: Path,
        consider_namespace_packages: bool,
    ) -> ModuleType:
        """
        Import and return a module from the given path, which can be a file (a module) or
        a directory (a package).
    
        :param path:
            Path to the file to import.
    
        :param mode:
            Controls the underlying import mechanism that will be used:
    
            * ImportMode.prepend: the directory containing the module (or package, taking
              `__init__.py` files into account) will be put at the *start* of `sys.path` before
              being imported with `importlib.import_module`.
    
            * ImportMode.append: same as `prepend`, but the directory will be appended
              to the end of `sys.path`, if not already in `sys.path`.
    
            * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
              to import the module, which avoids having to muck with `sys.path` at all. It effectively
              allows having same-named test modules in different places.
    
        :param root:
            Used as an anchor when mode == ImportMode.importlib to obtain
            a unique name for the module being imported so it can safely be stored
            into ``sys.modules``.
    
        :param consider_namespace_packages:
            If True, consider namespace packages when resolving module names.
    
        :raises ImportPathMismatchError:
            If after importing the given `path` and the module `__file__`
            are different. Only raised in `prepend` and `append` modes.
        """
        path = Path(path)
        mode = ImportMode(mode)
    
        if not path.exists():
            raise ImportError(path)
    
        if mode is ImportMode.importlib:
            # Try to import this module using the standard import mechanisms, but
            # without touching sys.path.
            try:
                pkg_root, module_name = resolve_pkg_root_and_module_name(
                    path, consider_namespace_packages=consider_namespace_packages
                )
            except CouldNotResolvePathError:
                pass
            else:
                # If the given module name is already in sys.modules, do not import it again.
                with contextlib.suppress(KeyError):
                    return sys.modules[module_name]
    
                mod = _import_module_using_spec(
                    module_name, path, pkg_root, insert_modules=False
                )
                if mod is not None:
                    return mod
    
            # Could not import the module with the current sys.path, so we fall back
            # to importing the file as a single module, not being a part of a package.
            module_name = module_name_from_path(path, root)
            with contextlib.suppress(KeyError):
                return sys.modules[module_name]
    
            mod = _import_module_using_spec(
                module_name, path, path.parent, insert_modules=True
            )
            if mod is None:
                raise ImportError(f"Can't find module {module_name} at location {path}")
            return mod
    
        try:
            pkg_root, module_name = resolve_pkg_root_and_module_name(
                path, consider_namespace_packages=consider_namespace_packages
            )
        except CouldNotResolvePathError:
            pkg_root, module_name = path.parent, path.stem
    
        # Change sys.path permanently: restoring it at the end of this function would cause surprising
        # problems because of delayed imports: for example, a conftest.py file imported by this function
        # might have local imports, which would fail at runtime if we restored sys.path.
        if mode is ImportMode.append:
            if str(pkg_root) not in sys.path:
                sys.path.append(str(pkg_root))
        elif mode is ImportMode.prepend:
            if str(pkg_root) != sys.path[0]:
                sys.path.insert(0, str(pkg_root))
        else:
            assert_never(mode)
    
>       importlib.import_module(module_name)

/usr/local/lib/python3.11/site-packages/_pytest/pathlib.py:587: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'test_solana_setup', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/importlib/__init__.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'test_solana_setup', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'test_solana_setup', import_ = <function _gcd_import at 0x76f09f2f3d80>

>   ???

<frozen importlib._bootstrap>:1176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'test_solana_setup', import_ = <function _gcd_import at 0x76f09f2f3d80>

>   ???

<frozen importlib._bootstrap>:1147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='test_solana_setup', loader=<_pytest.assertion.rewrite.AssertionRewritingHook object at 0x76f09e47eb90>, origin='/app/scripts/test_solana_setup.py')

>   ???

<frozen importlib._bootstrap>:690: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.assertion.rewrite.AssertionRewritingHook object at 0x76f09e47eb90>
module = <module 'test_solana_setup' from '/app/scripts/test_solana_setup.py'>

    def exec_module(self, module: types.ModuleType) -> None:
        assert module.__spec__ is not None
        assert module.__spec__.origin is not None
        fn = Path(module.__spec__.origin)
        state = self.config.stash[assertstate_key]
    
        self._rewritten_names[module.__name__] = fn
    
        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
        write = not sys.dont_write_bytecode
        cache_dir = get_cache_dir(fn)
        if write:
            ok = try_makedirs(cache_dir)
            if not ok:
                write = False
                state.trace(f"read only directory: {cache_dir}")
    
        cache_name = fn.name[:-3] + PYC_TAIL
        pyc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
        co = _read_pyc(fn, pyc, state.trace)
        if co is None:
            state.trace(f"rewriting {fn!r}")
            source_stat, co = _rewrite_test(fn, self.config)
            if write:
                self._writing_pyc = True
                try:
                    _write_pyc(state, co, source_stat, pyc)
                finally:
                    self._writing_pyc = False
        else:
            state.trace(f"found cached rewritten pyc for {fn}")
>       exec(co, module.__dict__)

/usr/local/lib/python3.11/site-packages/_pytest/assertion/rewrite.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    # test_solana_setup.py
    import asyncio
    from trading.chains.solana import JupiterExecutor
    
    async def test():
        config = {
            'jupiter_url': 'https://quote-api.jup.ag/v6',
            'solana_rpc_url': 'https://api.mainnet-beta.solana.com',
            'solana_private_key': 'YOUR_KEY_HERE',
            'max_slippage': 0.05
        }
    
        executor = JupiterExecutor(config)
        await executor.initialize()
    
        # Test quote (SOL â†’ USDC)
        quote = await executor.get_quote(
            input_mint='So11111111111111111111111111111111111111112',  # SOL
            output_mint='EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',  # USDC
            amount_lamports=100000000,  # 0.1 SOL
        )
    
        if quote:
            print(f"âœ… Quote received!")
            print(f"Input: {quote.in_amount / 1e9} SOL")
            print(f"Output: {quote.out_amount / 1e6} USDC")
            print(f"Price Impact: {quote.price_impact_pct:.2f}%")
        else:
            print("âŒ Failed to get quote")
    
        await executor.cleanup()
    
>   asyncio.run(test())

scripts/test_solana_setup.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

main = <coroutine object test at 0x76f08e82b010>

    def run(main, *, debug=None):
        """Execute the coroutine and return the result.
    
        This function runs the passed coroutine, taking care of
        managing the asyncio event loop and finalizing asynchronous
        generators.
    
        This function cannot be called when another asyncio event loop is
        running in the same thread.
    
        If debug is True, the event loop will be run in debug mode.
    
        This function always creates a new event loop and closes it at the end.
        It should be used as a main entry point for asyncio programs, and should
        ideally only be called once.
    
        Example:
    
            async def main():
                await asyncio.sleep(1)
                print('hello')
    
            asyncio.run(main())
        """
        if events._get_running_loop() is not None:
            # fail fast with short traceback
            raise RuntimeError(
                "asyncio.run() cannot be called from a running event loop")
    
        with Runner(debug=debug) as runner:
>           return runner.run(main)
                   ^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/asyncio/runners.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncio.runners.Runner object at 0x76f0909c8850>
coro = <coroutine object test at 0x76f08e82b010>

    def run(self, coro, *, context=None):
        """Run a coroutine inside the embedded event loop."""
        if not coroutines.iscoroutine(coro):
            raise ValueError("a coroutine was expected, got {!r}".format(coro))
    
        if events._get_running_loop() is not None:
            # fail fast with short traceback
            raise RuntimeError(
                "Runner.run() cannot be called from a running event loop")
    
        self._lazy_init()
    
        if context is None:
            context = self._context
        task = self._loop.create_task(coro, context=context)
    
        if (threading.current_thread() is threading.main_thread()
            and signal.getsignal(signal.SIGINT) is signal.default_int_handler
        ):
            sigint_handler = functools.partial(self._on_sigint, main_task=task)
            try:
                signal.signal(signal.SIGINT, sigint_handler)
            except ValueError:
                # `signal.signal` may throw if `threading.main_thread` does
                # not support signals (e.g. embedded interpreter with signals
                # not registered - see gh-91880)
                sigint_handler = None
        else:
            sigint_handler = None
    
        self._interrupt_count = 0
        try:
>           return self._loop.run_until_complete(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/asyncio/runners.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>
future = <Task finished name='Task-1' coro=<test() done, defined at /app/scripts/test_solana_setup.py:5> exception=ValueError('Unsupported Solana private key format. Expected base58 (88 chars), hex (128 chars), or JSON array. Got length: 13')>

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
>       return future.result()
               ^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/asyncio/base_events.py:654: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def test():
        config = {
            'jupiter_url': 'https://quote-api.jup.ag/v6',
            'solana_rpc_url': 'https://api.mainnet-beta.solana.com',
            'solana_private_key': 'YOUR_KEY_HERE',
            'max_slippage': 0.05
        }
    
>       executor = JupiterExecutor(config)
                   ^^^^^^^^^^^^^^^^^^^^^^^

scripts/test_solana_setup.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <trading.chains.solana.jupiter_executor.JupiterExecutor object at 0x76f08e876690>
config = {'jupiter_url': 'https://quote-api.jup.ag/v6', 'max_slippage': 0.05, 'solana_private_key': 'YOUR_KEY_HERE', 'solana_rpc_url': 'https://api.mainnet-beta.solana.com'}
db_manager = None

    def __init__(self, config: Dict[str, Any], db_manager=None):
        """
        Initialize Jupiter executor
    
        Args:
            config: Flat config dict with keys like:
                - rpc_url: Solana RPC endpoint
                - private_key: Base58 encoded private key
                - max_slippage_bps: Maximum slippage in basis points (default: 500 = 5%)
                - enabled: Whether Solana trading is enabled
        """
        super().__init__(config, db_manager)
    
        # âœ… CRITICAL: DRY_RUN mode check (standardize key name)
        self.dry_run = config.get('DRY_RUN', True) or config.get('dry_run', True)
        if self.dry_run:
            logger.warning("ðŸ”¶ JUPITER EXECUTOR IN DRY RUN MODE - NO REAL TRANSACTIONS ðŸ”¶")
        else:
            logger.critical("ðŸ”¥ JUPITER EXECUTOR IN LIVE MODE - REAL MONEY AT RISK ðŸ”¥")
    
        # Jupiter v1 API Configuration
        self.jupiter_api_url = "https://lite-api.jup.ag/swap/v1"
    
        # Solana Configuration
        self.rpc_url = config.get('rpc_url') or config.get('solana_rpc_url', 'https://api.mainnet-beta.solana.com')
        self.max_slippage_bps = int(config.get('max_slippage_bps', 500))  # 5% default
    
        # Initialize keypair from private key
        private_key = config.get('solana_private_key') or config.get('private_key')
        # âœ… ADD DECRYPTION LOGIC:
        if private_key and private_key.startswith('gAAAAA'):  # Encrypted format
            try:
                from cryptography.fernet import Fernet
                encryption_key = config.get('encryption_key') or os.getenv('ENCRYPTION_KEY')
                if encryption_key:
                    cipher = Fernet(encryption_key.encode())
                    private_key = cipher.decrypt(private_key.encode()).decode()
                    logger.info("âœ… Solana private key decrypted")
            except Exception as e:
                logger.error(f"Failed to decrypt Solana private key: {e}")
                raise
    
        if private_key and Keypair:
            try:
                # âœ… IMPROVED: Validate and handle multiple formats
                if isinstance(private_key, str):
                    # Try base58 format first (most common, 88 chars)
                    if len(private_key) == 88:
                        try:
                            private_key_bytes = base58.b58decode(private_key)
                            if len(private_key_bytes) != 64:
                                raise ValueError(f"Invalid key length: {len(private_key_bytes)}, expected 64")
                            self.keypair = Keypair.from_bytes(private_key_bytes)
                            logger.info("âœ… Loaded Solana keypair from base58 string")
    
                        except Exception as e:
                            raise ValueError(f"Invalid base58 Solana private key: {e}")
    
                    # Try hex format (128 chars)
                    elif len(private_key) == 128:
                        try:
                            private_key_bytes = bytes.fromhex(private_key)
                            self.keypair = Keypair.from_bytes(private_key_bytes)
                            logger.info("âœ… Loaded Solana keypair from hex string")
                        except Exception as e:
                            raise ValueError(f"Invalid hex Solana private key: {e}")
    
                    # Try JSON array format [1,2,3,...]
                    elif private_key.startswith('['):
                        try:
                            import json
                            key_array = json.loads(private_key)
                            private_key_bytes = bytes(key_array)
                            if len(private_key_bytes) != 64:
                                raise ValueError(f"Invalid key length: {len(private_key_bytes)}")
                            self.keypair = Keypair.from_bytes(private_key_bytes)
                            logger.info("âœ… Loaded Solana keypair from JSON array")
                        except Exception as e:
                            raise ValueError(f"Invalid JSON array Solana private key: {e}")
    
                    else:
>                       raise ValueError(
                            f"Unsupported Solana private key format. "
                            f"Expected base58 (88 chars), hex (128 chars), or JSON array. "
                            f"Got length: {len(private_key)}"
                        )
E                       ValueError: Unsupported Solana private key format. Expected base58 (88 chars), hex (128 chars), or JSON array. Got length: 13

trading/chains/solana/jupiter_executor.py:130: ValueError
=========================== short test summary info ============================
ERROR scripts/test_solana_setup.py - ValueError: Unsupported Solana private k...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
/usr/local/lib/python3.11/site-packages/_pytest/unraisableexception.py:67: PytestUnraisableExceptionWarning: Exception ignored in: <function JupiterExecutor.__del__ at 0x76f08c6b4180>

Traceback (most recent call last):
  File "/app/trading/chains/solana/jupiter_executor.py", line 923, in __del__
    if self.session and not self.session.closed:
       ^^^^^^^^^^^^
AttributeError: 'JupiterExecutor' object has no attribute 'session'

Enable tracemalloc to get traceback where the object was allocated.
See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.
  warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
